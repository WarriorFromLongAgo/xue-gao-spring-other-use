# xue-gao-write-other-use

采用分支的方式，手写框架，学习框架使用

# AOP1

## 初始状态

https://juejin.cn/post/7158274662823591943

```
1
假如现在有个厂家生产了一台生产冰淇淋的机器，支持蛋筒&杯装两种形式，
支持选择口味、大小 投放硬币，就可以根据选择生成冰淇淋 (这台机器就相当于一个类，
蛋筒和杯装是两个不同的方法，选择口味和规格按钮相当于参数，冰淇淋是返回值)。
输出：

1.开始生产杯装冰淇淋
2.草莓 杯装冰淇淋(大)
```

## 代理模式

```
2
过了一段时间厂家领导要做市场调研，想收集每天大家都选择了什么口味、什么规格，做市场分析。
为了应付这个工作，厂家雇了一个售货员看管机器，以后客户从售货员处购买，这个售货员先把需求记录下来，
然后再去按需操作机器，再把冰淇淋给用户(这个售货员就是这台机器的代理)。

这种实现起来也很简单，最简单的方式就是代理模式

输出：

1.开始生产杯装冰淇淋
2.草莓 杯装冰淇淋(大)
```

## 动态代理

```
通过售货员方式(代理模式)，很轻松实现需求记录。
后来厂家越做越大，冰淇淋机越来越多，引进了很多新机器，领导对新的机器质量不放心，于是规定说新机器不光要采集用户需求，
又要检查产出的冰淇淋是否达标。
这样导致每个机器不光要配一个售货员(代理)，每个售货员干的活还不一样，人力成本和培训成本急速提高。
这时候来了个代理公司说可以帮解决问题，只要厂家每次约定好某个冰淇淋机，计划好额外的工作(拦截器)，我们就培养出一个售货员 
，而厂家只要专心生产机器并做好拦截计划就好(代理公司根据约定培养出销售员的过程就是动态代理)。

关于拦截计划，双方约定了一个规范，否则随便写会造成阅读障碍。

输出：

记录需求：原味
开始生产蛋筒冰淇淋
对生产出的冰淇淋拍照原味 蛋筒冰淇淋(中)
客户拿到冰淇淋：原味 蛋筒冰淇淋(中)

就这样过了一段时间，厂家和代理公司配合很好，厂家专注维护机器制定拦截计划，代理公司专注培养代理售货员，分工明确，单一职责。
```

## 责任链模式

```
又过了一段时间，出现新需求，一台机器要加多个拦截计划：既要市场调研又要食品监督，
而且拒绝修改原有的拦截计划，只想新加入拦截计划让新旧拦截计划一起生效，这样一来代理公司又要做变动了

首先第一步，一个机器对应多个拦截计划

/** * 附加工作列表 */ 
List<MethodInterceptor> interceptors;

现在有多个计划，每个计划都包含了开始生产的标识，那怎么执行呐，循环执行肯定不行，
人家客户要一个冰淇淋你可能给人家生成多个(点了多次开始按钮)。
代理公司想出了解决方案，给每个售货员配一个调度员，这个调度员一个个执行拦截计划，
当某个拦截计划写着点击开始按钮时，不是实际的点击开始，而是进行下一个拦截计划(相当于把开始按钮调包了)，
最后再没有拦截计划时再实际点击开始按钮，这里有点绕，看下面的例子

比厂家一台机器有两个计划
食品监督计划：
Object invoke(MethodInvocation invocation) {
    //1.口味/规格记在食品监督小本上
    //2.开始生产冰淇淋(invocation.proceed())
    //3.生产出的冰淇淋拍个照发给厂家微信
}

市场调研计划：
Object invoke(MethodInvocation invocation) {
    //1.口味/规格记在市场调研小本上
    //2.开始生产冰淇淋(invocation.proceed())
}

实际来客户购买冰淇淋时，售货员拿到两个计划交给召唤出的调度员，调度员是这么调度的
按第一个计划(食品监督计划)先走
1.1 口味/规格记在食品监督小本上
1.2 开始生产冰淇淋(拿到这个指令时，调度员实际开始进行下一个计划)
├── 2.1 口味/规格记在市场调研小本上
├── 2.2 开始生产冰淇淋 ***此时没有下一个拦截计划，真正点击开始按钮***
1.3 生产出的冰淇淋拍个照发给厂家微信





```

## jdk动态代理

https://juejin.cn/post/7158275359471829029

https://juejin.cn/post/7158276035295838221

https://juejin.cn/post/7158276386602352648
