<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 定义状态
    const PENDING = "pending";
    const FULFILLED = "fulfilled";
    const REJECTED = "rejected";

    class SelfPromise {
        // 储存状态，初始值是 pending
        status = PENDING;
        // 成功之后的值
        value = null;
        // 失败之后的原因
        reason = null;

        constructor(executor) {
            // 将 resolve 和 reject 传给 new Promsie 的回调函数
            executor(this.resolve, this.reject);
        }

        // 箭头函数可以函数里面的 this 始终指向 Promise 实例对象
        resolve = (value) => {
            // 只有状态是 pending 的情况下，才改变为 fulfilled 状态
            if (this.status === PENDING) {
                this.status = FULFILLED;
                this.value = value;
            }
        };

        reject = (reason) => {
            // 只有状态是 pending 的情况下，才改变为 rejected 状态
            if (this.status === PENDING) {
                this.status = REJECTED;
                this.reason = reason;
            }
        };

        then(onFulfilled, onRejected) {
            if (this.status === FULFILLED) {
                // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。
                onFulfilled(this.value);
            } else if (this.status === REJECTED) {
                // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。
                onRejected(this.reason);
            }
        }
    }


    const p = new SelfPromise((resolve, reject) => {
        resolve("fulfilled");
        reject("rejected");
    });

    p.then(value => {
        console.log(value);
    }, reason => {
        console.log(reason);
    })

// fulfilled



</script>

</html>